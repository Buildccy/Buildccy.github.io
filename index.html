<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-我的第二篇博文" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/20/%E6%88%91%E7%9A%84%E7%AC%AC%E4%BA%8C%E7%AF%87%E5%8D%9A%E6%96%87/" class="article-date">
  <time class="dt-published" datetime="2021-04-20T12:46:29.000Z" itemprop="datePublished">2021-04-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/20/%E6%88%91%E7%9A%84%E7%AC%AC%E4%BA%8C%E7%AF%87%E5%8D%9A%E6%96%87/">我的第二篇博文</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="性能优化-串讲（转）"><a href="#性能优化-串讲（转）" class="headerlink" title="性能优化 串讲（转）"></a>性能优化 串讲（转）</h1><h2 id="问题列表"><a href="#问题列表" class="headerlink" title="问题列表"></a>问题列表</h2><p><strong>初始阶段 -&gt; 加载优化</strong></p>
<ol>
<li>首页加载慢的优化</li>
<li>优化图片的做法</li>
<li>实现 Webpack 打包优化</li>
<li>实现 CDN 加速</li>
</ol>
<p><strong>运行阶段 -&gt; 渲染优化</strong></p>
<ol>
<li>渲染十万条数据如何不造成卡顿</li>
</ol>
<h2 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h2><ul>
<li><input checked="" disabled="" type="checkbox"> 理解前端优化中两个分类</li>
<li><input disabled="" type="checkbox"> 了解导致前端性能问题的根本原因</li>
<li><input disabled="" type="checkbox"> 知道一些常用的性能问题的解决方案</li>
</ul>
<h2 id="问题详解"><a href="#问题详解" class="headerlink" title="问题详解"></a>问题详解</h2><h3 id="初始阶段"><a href="#初始阶段" class="headerlink" title="初始阶段"></a>初始阶段</h3><h4 id="1-首页加载慢的优化"><a href="#1-首页加载慢的优化" class="headerlink" title="1. 首页加载慢的优化"></a>1. 首页加载慢的优化</h4><p>#####问题分析</p>
<ul>
<li>首页加载图片过多</li>
<li>首页的请求量过多</li>
<li>首页请求的<strong>静态资源</strong>（HTML、CSS、JS、图片…）过大</li>
</ul>
<blockquote>
<p>结论：所有加载慢的问题最终都可以归纳成两个问题 <strong>多</strong> 和 <strong>大</strong>。Tips：还有网速不好和电脑太渣</p>
</blockquote>
<p>#####问题讲解</p>
<p>模拟面试对话</p>
<p>Q: 面试官爸爸   A: 你</p>
<p>Q：那既然你已经知道了首页加载慢的几个原因，那我先问你<strong>首页加载图片过多怎么处理？</strong></p>
<hr>
<p>A：<strong>减少</strong>图片不就完了吗</p>
<hr>
<p>Q：那我们的首页就是有这么多图片怎么办？</p>
<hr>
<p>如何分析：看看<a target="_blank" rel="noopener" href="https://www.taobao.com/">淘宝</a>怎么解决</p>
<hr>
<p>A: 可以通过<strong>懒加载</strong>的方式来减少<strong>首屏图片</strong>的加载量</p>
<hr>
<p>Q: 懒加载是什么原理？</p>
<hr>
<p>如何分析：看看<a target="_blank" rel="noopener" href="https://www.andreaverlicchi.eu/lazyload/demos/dynamic_content.html">懒加载的库</a></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">alt</span>=<span class="string">&quot;A lazy image&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;lazy.jpg&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;------ 滚动到特定位置的时候 ------&gt;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">alt</span>=<span class="string">&quot;A lazy image&quot;</span> <span class="attr">src</span>=<span class="string">&quot;lazy.jpg&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;lazy.jpg&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>



<hr>
<p>A:  懒加载原理就是监听滚动条事件，如果（滚动条距离浏览器顶部的高度 === 图片距离顶部的高度），那么就将 data-src 的值赋值到 src 上。</p>
<hr>
<p>Q: 那假设首页的小图片就是很多，比如有很多个小 ICON 怎么办？</p>
<hr>
<p>如何分析：还是看看<a target="_blank" rel="noopener" href="https://www.taobao.com/">淘宝</a>怎么解决</p>
<ol>
<li>对于纯色系<strong>小图标</strong>可以使用 <a target="_blank" rel="noopener" href="https://www.iconfont.cn/help/detail?&helptype=code">iconfont</a> 来解决<ul>
<li>设置 font-family 的 CSS 属性</li>
</ul>
</li>
<li>对于一些彩色的<strong>小图片</strong>可以使用雪碧图<ul>
<li>把所有小图片拼接到一张大图片上</li>
<li>并使用 background-position 的 CSS 属性来修改图片坐标</li>
</ul>
</li>
</ol>
<hr>
<p>A: 可以分别使用 iconfont 和雪碧图来处理小图标和小图片</p>
<hr>
<blockquote>
<p>总结：</p>
<p>首页加载图片过多的问题，可以通过以下几种方法解决：</p>
<ol>
<li>通过懒加载的方式处理非首屏的图片</li>
<li>对于小图标可以采用 iconfont 的方式解决</li>
<li>对于小图片可以采用雪碧图的方式解决</li>
</ol>
</blockquote>
<p>Q: <strong>首页的请求量过多怎么解决？</strong></p>
<hr>
<p>如何分析：</p>
<p>​    先通过工具来确定是哪些类型的资源请求过多</p>
<ol>
<li><p>通过浏览器的 Network 可以确定首页加载的资源和请求量</p>
<ul>
<li><p>requests：请求数量</p>
</li>
<li><p>resources：前端资源总大小</p>
</li>
<li><p>DOMContentLoaded： 浏览器已经完全加载了 HTML， 其他静态资源（ JS, CSS, 图片等）并没有下载完毕（能看，不能用）</p>
</li>
<li><p>Load：浏览器已经加载了所有的静态资源（能用了）</p>
</li>
</ul>
</li>
<li><p>通过 converge 来查看代码的使用状况</p>
<ul>
<li>只针对 JS 和 CSS</li>
<li>可以看出哪些代码虽然加载了但是没有执行</li>
<li>没有执行的代码可以考虑一下是否可以懒加载？</li>
</ul>
</li>
</ol>
<hr>
<p>A:  可以通过<strong>减少</strong>资源的请求量</p>
<ul>
<li>通过 <a target="_blank" rel="noopener" href="https://tengine.taobao.org/download/nginx@taobao.pdf">nginx 服务器</a> （可用来做 CDN，<strong>用来处理静态资源</strong>）来做<strong>资源文件合并</strong> <a target="_blank" rel="noopener" href="https://github.com/alibaba/nginx-http-concat">combo</a> – <strong>将多个JavaScript、CSS文件合并成一个</strong><ul>
<li>扩展：<a target="_blank" rel="noopener" href="https://www.aliyun.com/product/list">日常企业项目</a>中服务器按照功能区分：<ul>
<li><strong>应用服务器</strong>：服务端语言运行的服务器（Java，NodeJS…）放淘宝应用的位置</li>
<li>数据库服务器：放数据库的服务器</li>
<li>存储服务器：放大型文件的服务器（例如各种网盘）</li>
<li><strong>CDN服务器</strong>：<strong>放静态资源</strong>的服务器（JS，CSS, 图片, 字体…）</li>
</ul>
</li>
</ul>
</li>
<li>通过打包工具（Webpack）来做资源文件的<strong>物理打包</strong>（相对没有第一种灵活）</li>
</ul>
<p>Q: 只有通过合并静态资源的方式才能减少资源请求量吗？</p>
<hr>
<p>如何分析：</p>
<p>​    除了从资源层面来解决问题，还可以从我们自己写的代码本身来考虑。</p>
<ol>
<li><p>对于引入的一些比较大型的第三方库，比如 组件库（<a target="_blank" rel="noopener" href="https://ant.design/docs/react/getting-started-cn#%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD">antd</a>，<a target="_blank" rel="noopener" href="https://element.eleme.cn/#/zh-CN/component/quickstart#an-xu-yin-ru">element-ui</a>），函数库（<a target="_blank" rel="noopener" href="https://github.com/lodash/babel-plugin-lodash">lodash</a>）等，<strong>务必设定按需加载</strong>。Tips: 一般都是用 Babel 插件来实现的</p>
</li>
<li><p>可以通过<strong>前端</strong>路由懒加载的方式（只限于 <a target="_blank" rel="noopener" href="https://preview.pro.ant.design/dashboard/analysis">SPA 应用</a>）</p>
<ul>
<li>使用 <a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/code-splitting.html#reactlazy">React lazy</a> 进行动态路由的加载（React 16.6 以上版本才可以使用 React lazy）</li>
<li>演示 React lazy 的使用</li>
</ul>
</li>
</ol>
<hr>
<p>A: 当然不是，还可以从代码层面的优化，比如说：</p>
<pre><code> 1. 如果在项目中引入了比较大型的第三方库，那就可以通过特定的 Babel 插件来进行按需加载
 2. 在路由层面也可以使用 React lazy 进行动态路由的加载，从而可以减少首页的 JS 和 CSS 的大小
</code></pre>
<hr>
<p>Q：那我问你为什么 React lazy 可以进行动态路由的加载？</p>
<hr>
<p>如何分析：先看看使用方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1. 引入 react lazy, 并且使用 import 动态导入组件</span><br><span class="line">import &#123; lazy &#125; from &#39;react&#39;; &#x2F;&#x2F; 静态导入</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lazy(() &#x3D;&gt; import(&#39;.&#x2F;Home&#39;)); &#x2F;&#x2F; 动态导入</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2. 引入 Suspense 组件，并使用 Suspense 将根组件包裹起来，并使用 fallback props 传入 loading 组件</span><br><span class="line">import &#123; Suspense &#125; from &#39;react&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 注意：使用 lazy 加载的组件，必须是 Suspense 子组件，或者孙组件</span><br><span class="line">&lt;Suspense fallback&#x3D;&#123;&lt;div&gt;Loading...&lt;&#x2F;div&gt;&#125;&gt;</span><br><span class="line">	&lt;OtherComponent &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;Suspense&gt;</span><br></pre></td></tr></table></figure>



<p>动态导入(<a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/code-splitting.html#import">dynamic import</a>)：当代码运行 import 的时候，再导入组件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">&quot;./math&quot;</span>).then(<span class="function"><span class="params">math</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(math.add(<span class="number">16</span>, <span class="number">26</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似于 fetch，都是返回一个 Promise</span></span><br><span class="line"></span><br><span class="line">fetch(<span class="string">&quot;./math&quot;</span>).then(<span class="function"><span class="params">math</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(math.add(<span class="number">16</span>, <span class="number">26</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p>演示 Webpack 的代码分割</p>
<p><img src="./assets/1.png" alt="1"></p>
<blockquote>
<p>结论：</p>
<ol>
<li><p>import(‘xxx’) 返回的是一个 Promise </p>
</li>
<li><p>Webpack 只要遇到了 import(‘xxx’)，就会把括号里引入的内容单独打一个包</p>
</li>
</ol>
</blockquote>
<hr>
<p>A:  首先 React lazy 是使用了 dynamic import 的标准，webpack 只要遇到了 dynamic import， 就会把里面引入的内容单独打一个包。</p>
<p>由于 dynamic import 返回的是一个 Promise，所以可以使用 Promise 的状态来做<strong>渲染的流程控制</strong>。</p>
<p>如果当前 Promise 是 pending 状态，那么就渲染 Loading 组件，如果 Promise 是 resolve 状态那么就渲染动态导入的组件。</p>
<hr>
<blockquote>
<p>总结：</p>
<p>首页的请求量过多，可以通过一些手段来<strong>减少</strong>资源的请求量，比如：</p>
<ol>
<li>通过 nginx 服务器来做资源文件的合并或者通过 Webpack 等打包工具进行物理打包</li>
<li>在代码层面，对于需要引入一些大型第三方库的时候，可以通过特定的 Babel 插件来进行按需加载</li>
<li>还有可以使用 React lazy 或其他动态导入方案来进行前端路由层面的动态加载，从而可以减少首页的 JS 和 CSS 的大小</li>
</ol>
</blockquote>
<p>Q: <strong>首页请求的资源（CSS、JS、图片…）过大怎么解决？</strong></p>
<hr>
<p>A: 把资源变小不就完了吗？</p>
<hr>
<p>Q: 怎么变小？</p>
<hr>
<p>A: </p>
<ol>
<li>要分资源文件，CSS，JS，图片等要分开来处理</li>
<li>CSS 和 JS 可以通过 Webpack 来进行<a target="_blank" rel="noopener" href="https://tool.chinaz.com/tools/jscodeconfusion.aspx">混淆和压缩</a> （下个题目讲）<ul>
<li>混淆：将 JS 代码进行字符串加密（最大层度减少代码，比如将长变量名变成单个字母等等）</li>
<li>压缩：去除注释空行以及 console.log 等调试代码</li>
</ul>
</li>
<li>图片也可以进行压缩（下个题目讲）<ul>
<li>可以通过自动化工具来压缩图片</li>
<li>对图片进行转码 -&gt; base64 格式</li>
<li>使用 WebP 格式</li>
</ul>
</li>
<li>通过开启 gzip 进行<strong>全部资源</strong>压缩<ul>
<li>gzip: 是一种压缩文件格式，可以对任何文件进行压缩（类比于文件压缩）</li>
<li>可以通过 nginx 服务器的配置项进行开启（演示 <code>/usr/local/etc/nginx</code>）</li>
</ul>
</li>
</ol>
<hr>
<p>#####答题思路</p>
<blockquote>
<p>对于首页加载慢的问题，一般是由于首页加载资源过多，并且资源过大导致。所以应对的策略就减<strong>少</strong>资源的数量以及减<strong>小</strong>资源的大小。</p>
<ul>
<li>对于图片可以懒加载，减小首屏图片加载量。以及对于小图标和小图片和分别使用 iconfont 和 雪碧图来解决，最大程度减少首屏图片数量，从而提升首页渲染性能。</li>
<li>对于其他资源可以通过打包（nginx combo 或者 Webpack 打包）来合并资源，并可以通过懒加载路由的方式来减小首页 JS 的加载量</li>
<li>减小资源的方式可以通过压缩和混淆加密来减小文件体积，图片则可以使用工具来压缩或者使用 webp 格式。</li>
<li>同时可在服务器端开始 gzip 压缩来最大化减少所有文件体积。</li>
</ul>
<p>前端中最常见资源：HTML、CSS、JS、图片</p>
</blockquote>
<p>####2. 优化图片的做法</p>
<h5 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h5><ol>
<li>减<strong>少</strong>图片的请求 – 可懒加载图片</li>
<li>减<strong>小</strong>图片的大小</li>
</ol>
<h5 id="问题讲解"><a href="#问题讲解" class="headerlink" title="问题讲解"></a>问题讲解</h5><p>Q: 好，那你刚刚说可以使用自动化工具对图片进行压缩，你是使用什么工具？</p>
<hr>
<p>A: 用 熊猫站 不就完了吗？</p>
<hr>
<p>如何分析</p>
<p>​    <a target="_blank" rel="noopener" href="https://tinypng.com/">熊猫站</a>：智能压缩 PNG 和 JPG 的一个网站</p>
<ol>
<li>可以对图片进行<strong>等比例无损压缩</strong></li>
</ol>
<hr>
<p>Q: 那你认为为什么这个工具可以同比例无损压缩？</p>
<hr>
<p>如何分析</p>
<p>​    看看熊猫站的描述</p>
<blockquote>
<p>通过相似颜色“量化”的技术来减少颜色数量，并且可以将 24 位的 PNG 文件转化成 8位的彩色图片。同时可以将<strong>不必要的元数据</strong>进行剥离。</p>
<p>–&gt; 翻译成人话</p>
<p><strong>通过减少颜色的数量以及不必要的数据来实现文件压缩</strong></p>
</blockquote>
<hr>
<p>A：通过减少颜色的数量以及不必要的数据来实现文件压缩 </p>
<hr>
<p>Q: 非常 nice，但是这是方式不是有一个问题？难道每当我需要处理图片的时候，就要进入这个网站去上传一下吗？这样不仅仅效率低，还不安全。</p>
<hr>
<p>A: 熊猫站很佛系的，他们把图片压缩工具 <a target="_blank" rel="noopener" href="https://tinypng.com/developers/reference/nodejs">开放</a> 出来了。可以使用 npm 安装开源包，就可以在我们本地进行图片压缩啦。</p>
<hr>
<p>Q: 那除了这个方式还有什么其他的方式来优化图片吗？</p>
<hr>
<p>如何分析</p>
<p>​    对图片进行转码 -&gt; <a target="_blank" rel="noopener" href="https://c.runoob.com/front-end/59">base64 格式</a></p>
<hr>
<p>A: 可以使用 Webpack 的 <a target="_blank" rel="noopener" href="https://www.webpackjs.com/loaders/url-loader/">url-loader</a> 进行图片策略配置，将<strong>小图</strong>转换成 base64 格式，因为 <strong>base64 格式的图片的作用是减少资源的数量，但是 base64  格式的图片会增大原有图片的体积</strong></p>
<hr>
<p>A:  还有一种方式就是使用 webp 格式的图片</p>
<hr>
<p>如何分析</p>
<p>​    图片格式有很多种，PNG、JPG、GIF，还有新的 WebP 格式</p>
<p>​    WebP 的优势：</p>
<p>​    根据 Google 的测试，同等条件等比例无损压缩后的 WebP 比 PNG 文件少了 26％ 的体积。并且图片越多，压缩后的体积优势越明显。</p>
<p><strong>压缩率比较，JPG vs WebP</strong></p>
<p><img src="./assets/2.jpg" alt="2"></p>
<p><strong>加载时间比较，JPG vs WebP</strong></p>
<p><img src="./assets/3.jpg" alt="3"></p>
<p><a target="_blank" rel="noopener" href="https://www.upyun.com/webp">体验一下 WebP</a></p>
<hr>
<p>#####答题思路</p>
<blockquote>
<p>图片的优化，也是从两个方面来考虑：<strong>太多</strong> 和 <strong>太大</strong>。</p>
<ul>
<li><p>可以通过懒加载<strong>减少</strong>图片的请求，或者通过雪碧图来合并图片，以及将小图转化成 base64 的格式，来解决多的问题。</p>
</li>
<li><p>图片大的问题，可以通过自动化压缩工具来压缩图片，或者使用 WebP 格式的图片。</p>
</li>
</ul>
</blockquote>
<h4 id="3-实现-Webpack-打包优化"><a href="#3-实现-Webpack-打包优化" class="headerlink" title="3. 实现 Webpack 打包优化"></a>3. 实现 Webpack 打包优化</h4><p>#####问题分析</p>
<ol>
<li>减<strong>少</strong>包数量</li>
<li>减<strong>小</strong>包体积</li>
</ol>
<p>#####问题讲解</p>
<p>Q: 我问你，怎么使用 Webpack 进行打包优化？</p>
<hr>
<p>A: 少 和 小</p>
<hr>
<p>Q: 怎么样少，怎么样小</p>
<hr>
<p>如何分析</p>
<p>少 -&gt; 使用 Webpack 进行物理打包。</p>
<p>小 -&gt; 使用 Webpack 进行混淆和压缩，所有与 Webpack 优化相关的配置都是在 <a target="_blank" rel="noopener" href="https://webpack.docschina.org/configuration/optimization/">optimization</a> 这个配置项里管理。</p>
<blockquote>
<p>从 webpack 4 开始，会根据你选择的 <a target="_blank" rel="noopener" href="https://webpack.docschina.org/concepts/mode/">mode</a> 来执行不同的优化，不过所有的优化还是可以手动配置和重写。</p>
<p>development：不混淆，不压缩，不优化</p>
<p>production：混淆 + 压缩，自动内置优化</p>
<p>结论：只需要将 mode 改成 production 即可</p>
</blockquote>
<p>A: 使用 Webpack 对代码进行混淆和压缩，并且可以使用 React lazy 进行拆包，结合路由进行按需加载。</p>
<hr>
<p>Q: 那这里是不是有个问题？既然你对文件进行拆包处理，那么肯定会造成文件变多，是不是有矛盾？</p>
<hr>
<p>如何分析</p>
<p>其实不冲突，因为拆包后的文件，不可能同时加载的，所以就不会造成同一时间资源请求过多的请求。</p>
<p><strong>但是要注意打包策略</strong></p>
<p>我们通常会把包，分为两类</p>
<p>第三方包（node_modules 里面的）</p>
<p>自己实现的代码（src 目录里面的）</p>
<pre><code>- 公共的
- 非公共的
</code></pre>
<p>所以我们可以把第三方包打一个包，公共的代码打一个包，非公共的代码打一个包。</p>
<p>第三方包：改动频率 – 小</p>
<p>公共代码包：改动频率 – 中</p>
<p>非公共代码包：改动频率 – 高</p>
<p>所以可以将 <strong>打包策略</strong> 结合 <strong>网络缓存</strong> 来做优化</p>
<p>对于不需要经常变动的资源（第三方包），可以使用 <code>Cache-Control: max-age=31536000</code>（缓存一年） 并配合协商缓存 <code>ETag</code> 使用（一旦文件名变动才会下载新的文件）</p>
<p>对于需要频繁变动的资源（代码包），可以使用 <code>Cache-Control: no-cache</code> 并配合 <code>ETag</code> 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。</p>
<hr>
<p>A: 其实不冲突，因为拆包后的文件，不可能同时加载的，所以就不会造成同一时间资源请求过多的请求。但是可以使用 Webpack 的 optimization.splitChunks 进行<strong>打包策略的优化</strong>。将 node_modules 单独打包，以及将自己实现的代码也可以分为公共包和非公共包，并且分开打包。</p>
<p>最后还可以结合<strong>网络缓存</strong>来做加载性能优化。</p>
<hr>
<p>#####答题思路</p>
<blockquote>
<p>Webpack 打包优化，也是从两个方面来考虑：<strong>太多</strong> 和 <strong>太大</strong>。</p>
<ul>
<li>可以通过设置 mode = production 来默认实现 Webpack 对代码的混淆和压缩，从而最大程度的减少代码体积</li>
<li>使用 Webpack + dynamic import 并结合路由的入口文件做拆包处理。</li>
<li>并且可以设定一些打包策略，并配合网络缓存做最终的加载性能优化。</li>
</ul>
</blockquote>
<p>####4. 实现 CDN 加速</p>
<h5 id="问题分析-1"><a href="#问题分析-1" class="headerlink" title="问题分析"></a>问题分析</h5><ol>
<li>什么叫做 CDN（内容分发网络）<ul>
<li><strong>放静态资源</strong>的服务器（JS，CSS, 图片, 字体…）</li>
</ul>
</li>
<li>为什么 CDN 可以实现加速</li>
</ol>
<h5 id="问题讲解-1"><a href="#问题讲解-1" class="headerlink" title="问题讲解"></a>问题讲解</h5><p>​    为什么 CDN( 解决方案 -&gt; nginx ) 可以实现加速</p>
<p><img src="./assets/4.jpeg" alt="4"></p>
<p>游戏分区：北京一区，上海一区，广东一区……</p>
<p>Tips：CDN 服务器就是在你家门口放一台服务器，把所有的静态资源都同步到你家门口这台服务器上，以后只要你访问这个网站，都直接从这台服务器上下载静态资源。</p>
<p>Http1.1 请求：<strong>对于同一个协议、域名、端口，浏览器允许同时打开最多 6个 TCP 连接（最多同时发送 6个请求）</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">主站     Request URL: https:<span class="comment">//www.taobao.com/</span></span><br><span class="line"></span><br><span class="line">JS&amp;CSS  Request URL: https:<span class="comment">//g.alicdn.com/??kg/home-2017/1.4.17/lib/style/lazy.css</span></span><br><span class="line"></span><br><span class="line">图片     Request URL: https:<span class="comment">//img.alicdn.com/tfs/TB1_uT8a5ERMeJjSspiXXbZLFXa-143-59.png</span></span><br><span class="line"></span><br><span class="line">字体     Request URL: https:<span class="comment">//at.alicdn.com/t/font_403341_n8tj33yn5peng66r.woff</span></span><br></pre></td></tr></table></figure>





<p>扩展：<a target="_blank" rel="noopener" href="https://http2.akamai.com/demo">Http2.0</a>： 引入了<strong>多路复用</strong>的机制，可以最大化发送请求数量。</p>
<h5 id="答题思路"><a href="#答题思路" class="headerlink" title="答题思路"></a>答题思路</h5><blockquote>
<p>CDN 服务器主要是用来放静态资源的服务器，可以用来<strong>加速</strong>静态资源的下载</p>
<p>CDN 之所以能够加速，是因为会在很多地方都部署 CDN 服务器，如果用户需要下载静态资源，会自动选择最近的节点下载</p>
<p>同时由于 CDN 服务器的地址一般都跟主服务器的地址不同，所以可以破除浏览器对同一个域名发送请求的限制</p>
</blockquote>
<h3 id="运行阶段"><a href="#运行阶段" class="headerlink" title="运行阶段"></a>运行阶段</h3><p>####1. 渲染十万条数据如何不造成卡顿</p>
<h5 id="问题分析-2"><a href="#问题分析-2" class="headerlink" title="问题分析"></a>问题分析</h5><ol>
<li><p>为什么渲染很多条数据会造成浏览器卡顿</p>
<ol start="2">
<li>怎么优化长列表的情况</li>
</ol>
</li>
</ol>
<h5 id="问题讲解-2"><a href="#问题讲解-2" class="headerlink" title="问题讲解"></a>问题讲解</h5><ol>
<li><p>为什么渲染很多条数据会造成浏览器卡顿</p>
<p><img src="./assets/5.jpg" alt="4"></p>
</li>
</ol>
<blockquote>
<p>结论：</p>
<ol>
<li>无论是浏览器中的 DOM 和 BOM，还是 NodeJS，它们都是基于 JavaScript 引擎之上开发出来的</li>
<li>DOM 和 BOM 的处理最终都是要被转换成 JavaScript 引擎能够处理的数据</li>
<li>这个转换的过程很耗时</li>
<li><strong>所以在浏览器中最消耗性能的就是操作 DOM</strong></li>
</ol>
</blockquote>
<ol start="2">
<li>怎么优化渲染很多数据的情况</li>
</ol>
<p><strong>指导原则：尽可能的减少 DOM 的操作</strong></p>
<p>eg：假如有一个需求，我们要在一个页面中 ul 标签里渲染 <strong>十万</strong> 个 li 标签。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入十万条数据</span></span><br><span class="line"><span class="keyword">const</span> total = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">let</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;ul&#x27;</span>); <span class="comment">// 拿到 ul</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 懒加载的思路 -- 分段渲染</span></span><br><span class="line"><span class="comment">// 1. 一次渲染一屏的量</span></span><br><span class="line"><span class="keyword">const</span> once = <span class="number">20</span>;</span><br><span class="line"><span class="comment">// 2. 全部渲染完需要多少次，循环的时候要用</span></span><br><span class="line"><span class="keyword">const</span> loopCount = total / once;</span><br><span class="line"><span class="comment">// 3. 已经渲染了多少次</span></span><br><span class="line"><span class="keyword">let</span> countHasRender = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建虚拟节点，（使用 createDocumentFragment 不会触发渲染）</span></span><br><span class="line">  <span class="keyword">const</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line">  <span class="comment">// 循环 20 次</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; once; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> li = <span class="built_in">document</span>.createElement(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line">    li.innerText = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * total);</span><br><span class="line">    fragment.appendChild(li);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 最后把虚拟节点 append 到 ul 上</span></span><br><span class="line">  ul.appendChild(fragment);</span><br><span class="line">  <span class="comment">// 4. 已渲染的次数 + 1</span></span><br><span class="line">  countHasRender += <span class="number">1</span>;</span><br><span class="line">  loop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最重要的部分来了</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 5. 如果还没渲染完，那么就使用 requestAnimationFrame 来继续渲染</span></span><br><span class="line">  <span class="keyword">if</span> (countHasRender &lt; loopCount) &#123;</span><br><span class="line">    <span class="comment">// requestAnimationFrame 叫做逐帧渲染</span></span><br><span class="line">    <span class="comment">// 类似于 setTimeout(add, 16);</span></span><br><span class="line">    <span class="comment">// 帧：一秒钟播放多少张图片，一秒钟播放的图片越多，动画就约流畅</span></span><br><span class="line">    <span class="comment">// 1000/60 = 16</span></span><br><span class="line">    <span class="built_in">window</span>.requestAnimationFrame(add);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">loop();</span><br></pre></td></tr></table></figure>



<blockquote>
<p>结论：</p>
<ol>
<li>可以使用 document.createDocumentFragment 创建虚拟节点，从而避免引起没有必要的渲染</li>
<li>当所有的 li 都创建完毕后，一次性把虚拟节点里的 li 标签全部渲染出来</li>
<li>可以采取分段渲染的方式，比如一次只渲染一屏的数据</li>
<li>最后使用 <strong>window.requestAnimationFrame</strong> 来逐帧渲染</li>
</ol>
</blockquote>
<h5 id="答题思路-1"><a href="#答题思路-1" class="headerlink" title="答题思路"></a>答题思路</h5><blockquote>
<p>导致浏览器卡顿的原因一般都是<strong>操作 DOM</strong> 的次数太频繁。</p>
<p>如果想要渲染很多条数据不造成卡顿，那么就一定要尽可能的减少操作 DOM 的次数。</p>
<p>比方说 React 的虚拟 DOM，本质上就是用 JS 数据来模拟真实 DOM树，从而大大减少了操作真是 DOM 的次数。</p>
<p>还有在渲染的时候，可以使用 document.createDocumentFragment 创建虚拟节点，从而避免引起没有必要的渲染</p>
<p>也可以采取分段渲染的方式，最后使用 window.requestAnimationFrame 来<strong>逐帧渲染</strong></p>
</blockquote>
<h4 id="课程总结"><a href="#课程总结" class="headerlink" title="课程总结"></a>课程总结</h4><blockquote>
<p>记住：</p>
<p>在前端中性能优化的点主要分为两个阶段：</p>
<ol>
<li><p>初始阶段，主要就是加载方面优化的问题。所有问题的指导原则就两点：</p>
<ul>
<li>尽可能的<strong>减少</strong>前端资源的数量</li>
<li>尽可能的<strong>减小</strong>前端资源的大小</li>
</ul>
</li>
<li><p>运行阶段，主要就是渲染方面优化的问题。只要是在浏览器中，所有的问题的指导原则就是：</p>
<ul>
<li>尽可能的减少操作 DOM</li>
</ul>
</li>
</ol>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/20/%E6%88%91%E7%9A%84%E7%AC%AC%E4%BA%8C%E7%AF%87%E5%8D%9A%E6%96%87/" data-id="cknskliy20002ycv81icr3kem" data-title="我的第二篇博文" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%B8%8D%E7%9F%A5%E9%81%93%E5%86%99%E4%BB%80%E4%B9%88%EF%BC%8C%E5%B0%B1%E9%9A%8F%E4%BE%BF%E6%89%93%E4%B8%80%E4%BA%9B%E5%AD%97/" rel="tag">不知道写什么，就随便打一些字</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-我的第一篇博客" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/20/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/" class="article-date">
  <time class="dt-published" datetime="2021-04-20T11:03:22.000Z" itemprop="datePublished">2021-04-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/20/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/">我的第一篇博客</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p>内容</p>
<hr>
<h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><p>内容</p>
<hr>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/20/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/" data-id="cknsklixa0001ycv8cyo5douf" data-title="我的第一篇博客" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/20/hello-world/" class="article-date">
  <time class="dt-published" datetime="2021-04-20T10:53:15.018Z" itemprop="datePublished">2021-04-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/20/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/20/hello-world/" data-id="cknsklix40000ycv87twedw81" data-title="Hello World" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%8D%E7%9F%A5%E9%81%93%E5%86%99%E4%BB%80%E4%B9%88%EF%BC%8C%E5%B0%B1%E9%9A%8F%E4%BE%BF%E6%89%93%E4%B8%80%E4%BA%9B%E5%AD%97/" rel="tag">不知道写什么，就随便打一些字</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/%E4%B8%8D%E7%9F%A5%E9%81%93%E5%86%99%E4%BB%80%E4%B9%88%EF%BC%8C%E5%B0%B1%E9%9A%8F%E4%BE%BF%E6%89%93%E4%B8%80%E4%BA%9B%E5%AD%97/" style="font-size: 10px;">不知道写什么，就随便打一些字</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/04/20/%E6%88%91%E7%9A%84%E7%AC%AC%E4%BA%8C%E7%AF%87%E5%8D%9A%E6%96%87/">我的第二篇博文</a>
          </li>
        
          <li>
            <a href="/2021/04/20/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/">我的第一篇博客</a>
          </li>
        
          <li>
            <a href="/2021/04/20/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>